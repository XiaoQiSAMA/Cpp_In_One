# 设计模式实例

## 创建型模式

### 单例模式

一个类不管创建多少次对象，永远只能得到该类型的一个对象实例

例如: 日志模块(统一由一个日志对象管理)、数据库模块

[code_for_Singleton](../../src/design_pattern/singleton.cpp)

* 饿汉式单例模式: 还没有获取实例对象，实例对象就已经产生了
* 懒汉式单例模式: 唯一的实例对象，知道第一次获取他的时候，才创建

### 工厂模式

* 简单工厂  Simple Factory  
  * 把对象的创建封装在一个接口函数里，通过传入不同标识返回创建的对象
  * 优点: 客户不用自己负责new对象，不用了解对象创建的详细过程
  * 缺点: 提供创建对象实例的接口函数不闭合，不能对修改关闭

* 工厂方法  Factory Method
  * Factory基类，提供了一个纯虚函数(创建产品)，定义派生类(具体产品的工厂)负责创建对应的产品。
  * 优点: 模块化
  * 缺点: 1. 部分产品对象存在关联，创建逻辑不好设计 2. 工厂类过多，不易维护
* 抽象工厂  Abstract Factory
  * 把有关联关系的，属于一个产品簇的所有产品创建的接口函数放在一个抽象工厂里面AbstractFactory，派生类(具体产品的工厂)只需负责创建该产品簇里面所有的产品
  * 优点: 优化了工厂方法的缺点
  * 缺点: 抽象工厂类中的接口函数可能不满足于部分派生类的要求

MainIdea: 封装了对象的创建

[code_for_Factory](../../src/design_pattern/Factory.cpp)

## 结构型模式(类的组合关系)

### 代理模式

代理proxy模式 : 通过代理类，来控制实际对象的访问权限

[code_for_proxy](../../src/design_pattern/proxy.cpp)

* 基类: 老板
* 委托类: 老板对所有委托的处理过程
* 代理类: 根据权限情况调用委托类中对应权限的处理过程

### 装饰器模式 Decorator

$\bf 主要是增加现有类的功能。$通过子类来实现功能增强是可以的，但是代码中有太多的子类添加进去了。

[code_for_decorator](../../src/design_pattern/decorator.cpp)

### 适配器模式(面试常问)

让不兼容的接口可以在一起工作

[code_for_adapter](../../src/design_pattern/adapter.cpp)

类比为接口不兼容问题

1. 更换适配接口的硬件设备: 代码重构
2. 买一个接口转换设备:     添加适配器类

## 行为型模式(对象间的通信)

### 观察者-监听者模式(发布-订阅模式)

主要关注的是对象的一对多关系，也就是多个对象都依赖于一个对象，当该对象的状态发生改变时，其他对象都能够接收到相应的通知

[code_for_observer](../../src/design_pattern/observer.cpp)