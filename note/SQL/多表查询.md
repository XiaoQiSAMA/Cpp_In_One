# 多表查询
- 笛卡尔积(一般为错误的操作, 又称交叉连接CROSS JOIN)
	- 例如查询员工表中员工所在的部门名(位于部门表中)
		<pre>
		SELECT emp_id, dep_name 
		FROM employees, departments; 会返回两张表的条目的所有组合
		</pre>
	- 错误的原因: 缺少连接条件

- 关联查询(多表查询)
	- 使用连接条件进行约束, *理解为对交叉查询进行过滤*
		<pre>
		SELECT emp_id, dep_name 
		FROM employees, departments 
		WHERE employees.dep_id = departments.dep_id; # 关联条件
		</pre>
- 注意
	- 多个表中相同的的字段，在查询时应该明确来源
		<pre>
		SELECT emp_id, dep_name, dep_id  # 错误的，dep_id来源不明
		FROM employees, departments 
		WHERE employees.dep_id = departments.dep_id; 
		</pre>
		<pre>
		SELECT emp_id, dep_name, employees.dep_id  # 正确的
		FROM employees, departments 
		WHERE employees.dep_id = departments.dep_id; 
		</pre>
	- 多表查询，指明字段来源可以加速查询
	- 表可以有别名，方式与字段别名相同。**表具有别名时，查询时必须使用别名**
		<pre>
		SELECT e.emp_id, d.dep_name 
		FROM employees e, departments d
		WHERE e.dep_id = d.dep_id; # 关联条件
		</pre>
	- n个表不出现交叉查询的必要条件: **至少有(n-1)个条件**
		<pre>
		SELECT employees.employee_id, employees.last_name, departments.department_id, locations.city
		FROM employees, departments, locations
		WHERE employees.department_id = departments.department_id AND departments.location_id = locations.location_id;
		</pre>

- 多表查询的分类
	- 等值连接与非等值连接
		- 非等值连接: 连接条件含有不等关系的
			<pre>
			SELECT last_name, salary, grade_level
			FROM employees e, job_grades j
			WHERE e.salary >= j.lowest_sal AND e.salary <= j.highest_sal;
			</pre>
		- 等值连接: 连接条件不含有不等关系的
	- 自连接与非自连接
		- 自连接: 表中存在自引用
			<pre> # 查询员工姓名及其老板的姓名
			SELECT emp.employee_id, emp.last_name, mgr.employee_id, mgr.last_name
			FROM employees emp, employees mgr
			WHERE emp.manager_id = mgr.employee_id;
			</pre>
		- 非自连接: 表中不存在自引用
	- 内连接与外连接
		- 内连接: 合并具有相同字段的多个表中的相同行，结果不包含不匹配的行
		- 外连接: 除内连接能查询的行外，还能查询到不匹配的行
			- 左外连接
			- 右外连接
			- 满外连接

	- SQL99的连接
		- 基本操作
			<pre>
			表1 JOIN 表2 ON 连接条件;
			</pre>
		- 内连接
		<pre>
		SELECT last_name, department_name
		FROM employees e JOIN departments d
		ON e.department_id = d.department_id;	# 通过department_id连接emplyees表和deparements表。JOIN可以指明为INNER JOIN 
		</pre>
		- 外连接
		<pre>
		SELECT last_name, department_name
		FROM employees e LEFT JOIN departments d
		ON e.department_id = d.department_id;    # 左外连接。JOIN可以指明为OUTER JOIN，但LEFT不可省略

		SELECT last_name, department_name
		FROM employees e RIGHT JOIN departments d
		ON e.department_id = d.department_id;    # 右外连接

		SELECT last_name, department_name
		FROM employees e RIGHT JOIN departments d
		ON e.department_id = d.department_id
		UNION ALL
		SELECT last_name, department_name
		FROM employees e LEFT JOIN departments d
		ON e.department_id = d.department_id;    # 满外连接。即左外连接和右外连接的合计。删除ALL可以实现去重

		SELECT last_name, department_name
		FROM employees e LEFT JOIN departments d
		ON e.department_id = d.department_id
		WHERE e.department_id is NULL;    # 左外连接特有
		</pre>

- 合并: UNION与UNION ALL
	- 区别
		- UNION是去重的
		- UNION ALL是不去重的，因此效率更高

- 自然连接: NATURAL JOIN
	- 自动匹配相同的字段，并进行等值连

- USING
	- 使用USING(字段1, ...)来依据选取的字段进行连接
	- 要求这些字段在被连接表中是相同的