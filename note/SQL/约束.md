# 约束
- 为什么要约束
	- 约束是为了保证数据完整性(精确性和可靠性)
		- 实体完整性
		- 域完整性
		- 引用完整性
		- 用户自定义完整性
- 什么是约束
	- 表级别的强制规定(对字段的限制)

- 约束的类别
	- 作用字段不同: 单列约束 / 多列约束
	- 作用范围不同: 列级约束 / 表级约束
		- 列级约束: 在字段后声明的约束
		- 表级约束: 在所有字段声明完后声明的约束
	- 约束的功能
		- 非空约束: NOT NULL
			- 添加非空约束
			<pre>
			CREATE TABLE t_table(
			id INT(8) NOT NULL,	# 在字段声明的数据类型后追加NOT NULL即可
			last_name CHAR(5)
			)
			</pre>
			- 将字段修改为非空约束
			<pre>
			ALTER TABLE t_table
			MODIFY id INT(8) NOT NULL;	# 追加非空约束。此时注意表中相应字段不能存在NULL
			</pre>
			- 注意
				- 所有类型默认都允许NULL
				- 非空约束只能出现在列上，不能出现在组合上
				- 可以有多个列要求非空
				- 空字符串不等同于NULL，0也不等同于NULL
				- 非空约束注意两种场景: 赋值为NULL或赋值时缺省
		- 唯一性约束: UNIQUE
			- 添加列级唯一性约束
			<pre>
			CREATE TABLE t_table(
			id INT(8) UNIQUE,
			last_name CHAR(5)
			)
			</pre>
			- 追加列级唯一性约束
			<pre>
			ALTER TABLE t_table
			ADD CONSTRAINT [cons_name] UNIQUE(id);	# 追加唯一性约束。此时注意表中相应字段不能存在重复字段
			</pre>
			<pre>
			ALTER TABLE t_table
			MODIFY id INT(8) UNIQUE;
			</pre>
			- 添加表级唯一性约束
			<pre>
			CREATE TABLE t_table(
			id INT(8),
			last_name CHAR(5),
			[CONSTRAINT [cons_tmp_name]] UNIQUE(id) # 添加表级别的约束，cons_tmp_name为约束名称
			)
			</pre>
			- 添加表级复合唯一性约束
			<pre>
			CREATE TABLE t_table(
			id INT(8),
			last_name CHAR(5),
			[CONSTRAINT [cons_tmp_name]] UNIQUE(id, last_name)
			)
			</pre>
			<pre>
			CREATE TABLE t_table(
			id INT(8),
			last_name CHAR(5),
			UNIQUE (id, last_name)
			)
			</pre>
			- 删除唯一性约束
				<pre>
				ALTER TABLE t_table
				DROP INDEX cons_name;	# 通过删除唯一性索引来删除
				</pre>
			- 注意
				- NULL不受唯一性约束，可以出现多次
				- 复合唯一性约束需要所有约束字段完全相同才构成冲突
				- 复合唯一性约束只能是表级别的
		- 主键约束: PRIMARY KEY
			- 创建列级主键约束
				<pre>
				CREATE TABLE t_table(
				id INT PRIMARY KEY,
				last_name VARCHAR(16)
				)
				</pre>
			- 创建表级主键约束
				<pre>
				CREATE TABLE t_table(
				id INT;
				last_name VARCHAR(16),
				[CONSTRAINT] PRIMARY KEY(id)
				)
				</pre>
			- 修改时添加主键
				<pre>
				ALTER TABLE t_table
				ADD PRIMARY KEY (id)
				</pre>
			- 删除主键(啥b才会删除主键，因为主键是数据库构建B+树的依据)
				<pre>
				ALTER TABLE t_table
				DROP PRIMARY KEY;
				</pre>
			- 注意
				- 一个表中最多有1个主键
				- 主键约束相当于 非空约束+唯一性约束
				- 主键约束可在表上创建，也可在列上创建
				- 可以创建复合主键，此时这些列都不允许出现NULL
				- **不要修改主键的值**
				- 主键始终叫PRIMARY，不接受重命名
		- 外键约束: FOREIGN KEY
			- 限制字段的引用完整性，子表不允许添加主表不存在的值
			- 创建表时添加外键
				<pre>
				CREATE TABLE prim_table(
				id_prim INT(8) PRIMARY KEY,
				last_name_prim VARCHAR(16)
				);		# 创建主表
				
				CREATE TABLE fori_table(
				id_fori INT(8) PRIMARY KEY,
				last_name_fori VARCHAR(16),
				[CONSTRAINT [cons_name]] FOREIGN KEY (id_fori) REFERENCES prim_table(id_prim)  
				)		# 创建子表
				</pre>
			- 删除外键
				<pre>
				ALTER TABLE t_table 
				DROP FOREIGN KEY foreign_key_name; # 删除外键约束
				DROP INDEX foreign_key_name; # 删除外键约束的索引
				</pre>
			- 注意
				- 外键列只能引用主表的主键列
				- 创建含外键的子表时，必须先创建它的主表
				- 删除主表必须先删除子表(相当于不允许直接删除依赖项)
				- 删除主表的记录时，需要先删除子表中依赖于该记录的记录，然后才能删除主表记录
				- 一个表可以有多个外键
				- 删除外键约束后。需要手动删除对应的索引
				- **外键的使用会带来性能下降**，应该尽可能将外键对应的约束转移到应用层面进行，例如在java中约束相应字段
			- 约束的等级
				- Cascade方式: 主表上更新/删除记录时，自动更新/删除子表记录
				```
				[CONSTRAINT [cons_name]] FOREIGN KEY (id_fori) REFERENCES prim_table(id_prim) ON UPDATE CASCADE ON DELETE SET NULL; 更新采用cascade模式，删除采用set null模式
				```
				- set null方式: 主表上更新/删除记录时，自动更新/删除子表相应记录为null
				- no action方式: 子表存在引用时，不允许父表更新或删除
		- 检查约束: CHECK
			- 仅在MySQL8.0支持，即使明确写有CHECK，MySQL5.7也不会检查
			- 在添加记录时进行检查，仅当满足条件时才能添加，否则报错
			- 添加检查约束
				<pre>
				CREATE TABLE t_table(
				id INT,
				salary INT CHECK(salary > 2000),
				sex CHAR CHECK(sex IN ('M', ''))
				)
				</pre>
		- 默认值约束: DEFAULT
			- 设置字段的默认值
				<pre>
				CREATE TABLE t_table(
				id INT,
				salary INT DEFAULT 2105
				)
				</pre>
			- 追加或更改默认值约束
				<pre>
				ALTER TABLE t_table
				MODIFY salary INT(16) DEFAULT 3000
				</pre>
			- 注意
				- 未设置DEFAULT时默认为NULL
	- 自增列: AUTO_INCREMENT
		- 某个字段的值自增
		- 创建自增
			<pre>
				CREATE TABLE t_table(
				id INT PRIMARY KEY AUTO_INCREMENT,
				last_name VARCHAR(16)
				)
			</pre>
		- 注意
			- 一个表最多有1个自增列
			- 自增初始值为1，但可修改
			- MySQL57的自增值储存在内存中，因此重启会自动恢复为已存记录的最大值，MySQL8.0将当前自增值写入储存，因此不受重启影响
			- **自增列必须为整型的**
			- **自增列必须是主键列或唯一性列**
			- 为自增列赋值为0或NULL时，会继续在已存最大值继续增加
			- 为自增列赋值大于已存最大值，复制成功并更新最大值

- 如何操作约束
	- 查看约束
		<pre>
		SELECT * FROM information_schema.table_constraints
		WHERE table_name='xxx';
		</pre>
