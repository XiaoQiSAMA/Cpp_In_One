# 查询: SELECT

### 基本操作

- 选择特定字段

<pre>
SELECT 字段1, ... 字段n FROM 表名;
</pre>
- 选择所有字段
<pre>
SELECT * FROM 表名;
</pre>
- 没有表时，用DUAL作为“缺省”的表名
<pre>
SELECT * FROM DUAL;
</pre>

### 列的别名

- 方式1: AS

<pre>
SELECT 字段 AS 别名 FROM 表名;
</pre>

- 方式2: 省略AS，**使用空格隔开**

<pre>
SELECT 字段 别名 FROM 表名;
</pre>

- 别名含有空格时的方式2需要**双引号**

<pre>
SELECT 字段 "别 名" FROM 表名;
</pre>

### 行去重: DISTINCT

- 单字段的

<pre>
SELECT DISTINCT class_id FROM student;
</pre>

- 多字段的

<pre>
SELECT name, DISTINCT class_id FROM student; # 错误的,name行与class_id行数量不一致
</pre>
<pre>
SELECT DISTINCT class_id, name FROM student; # 正确的,此时同时考虑了class_id和name作为重复的判断依据
</pre>

### 空值参与运算: NULL

- *NULL不等同于0*

<pre>
SELECT employee_id, salary, salary *(1  +commission_pct)* 12 FROM employees; # 不合理的，默认含有NULL的运算结果为NULL
</pre>
<pre>
SELECT employee_id, salary, salary *(1  +IFNULL(commission_pct, 0))* 12 FROM employees; # 合理的，设定使用0替换NULL
</pre>

### 着重号 ``

- 当表名是关键字时，需要进行转义，例如

<pre>
SELECT * FROM `ORDER`;
</pre>

- 普通字段也可以使用着重号，但一般不加

### 查询常数

- 当SELECT后跟随常数时，SQL会为返回的每一个条目都添加这一常数

<pre>
SELECT 123, class_id FROM student;
</pre>

### 显示表结构: DESC, DESCRIBE

- 显示表中字段的详细信息

<pre>
DESCRIBE employees;
</pre>

- 返回的每一行为原表中的一个字段
- 返回的每一列为原表中的一个字段的属性(数据类型等)

# 过滤: WHERE

### 基本操作

<pre>
SELECT 字段 FROM 表名 WHERE 条件;
</pre>

### *过滤条件的字符串忽略大小写，这是MySQL的不严谨性*

- 在MySQL中，以下语句是等价的

<pre>
SELECT * FROM student WHERE last_name = "Ting";
</pre>
<pre>
SELECT * FROM student WHERE last_name = "ting";
</pre>

- 注意
- 列的别名**不能**在WHERE中使用
- WHERE一定紧跟FROM
- SQL执行顺序
- FROM确定表
- WHERE过滤条目
- SELECT选择字段(此时才有别名)
- ORDER BY排序

# 运算符

### 算术运算符: + - * /(div) %(mod)

  - + 在SQL中没有“连接”作用，会将字符串转为数值后参与计算(隐式转换)
- 非“数值”的字符会被转换为0后参与计算

<pre>
SELECT 100.01 + '1' FROM DUAL; # 输出101.01
</pre>
<pre>
SELECT 100.01 + 'a' FROM DUAL; # 输出100.01
</pre>

### 比较运算符: =  <=>  !=  <>  <  >  <=  >=  

- 不安全的等于"="和不等于"!="
- 存在隐式转换，例如：

<pre>
SELECT 0 = 'a'; # 两边不都是字符(串)，则隐式转换后比较。输出1
</pre>
<pre>
SELECT 1 = 'a'; # 输出0
</pre>
<pre>
SELECT 'a' = 'a'; # 两边都是字符(串)，则按ASCII比较。输出1
</pre>
<pre>
SELECT 'b' = 'a'; # 输出0
</pre>

- 有NULL参与比较，结果一定是NULL

<pre>
SELECT NULL = 1; # 输出NULL
</pre>
<pre>
SELECT NULL = NULL; # 输出NULL
</pre>

- 安全的等于"<=>"和不等于"<>"
- 在没有NULL的比较中，"<>="与"="是相同的，"<>"与"!="是相同的
- 在含有NULL的运算中

<pre>
SELECT NULL = 1; # 输出0
</pre>
<pre>
SELECT NULL = NULL; # 输出1
</pre>

### 其他的比较运算符

- 空与非空: IS NULL / IS NOT NULL / ISNULL(字段)

<pre>
SELECT id FROM student WHERE score IS NULL;
</pre>

- 最小与最大: LEAST(字段1, ...) / GREATEST(字段1, ...)

<pre>
SELECT LEAST('dada', 'rrw') FROM DAUL;
</pre>

- 区间(包含边界的，连续的): BETWEEN / AND

<pre>
SELECT id FROM student WHERE score BETWEEN 60 AND 100;
</pre>

- 包含(不连续的): IN / NOT IN

<pre>
SELECT id FROM student WHERE class_id IN (10, 20, 30);
</pre>

- 模糊查询: LIKE
- 使用'%'来匹配不个数的不定字符

<pre>
SELECT id FROM student WHERE name LIKE '%G%'; # 查询名字包含'G'的条目
</pre>

- 使用'_'来匹配1个的不定字符

<pre>
SELECT id FROM student WHERE name LIKE '_G%'; # 查询名字包含'G'的条目，且G为第2个字符
</pre>

- 正则表达式: REGEXP / RLIKE

### 逻辑运算符

- 逻辑与: AND &&
- *优先级高于OR*
- 逻辑或: OR ||
- 逻辑非: NOT !
- 逻辑异或: XOR

### 位运算符

- 位与 &
- 位或 |
- 位异或 ^
- 位取反 ~
- 位右移 >>
- 位左移 <<

# 排序: ORDER BY

- 默认的顺序: 添加顺序
- 基本操作
- 升序(ASC, 默认的)

<pre>
SELECT 字段1, ... 字段n FROM 表名 ORDER BY 字段;
</pre>
<pre>
SELECT 字段1, ... 字段n FROM 表名 ORDER BY 字段 ASC;
</pre>

- 降序(DESC)

<pre>
SELECT 字段1, ... 字段n FROM 表名 ORDER BY 字段 DESC;
</pre>

- 二级排序
- 给定多个排序条件

<pre>
SELECT 字段1, ... 字段n FROM 表名 ORDER BY 字段1 ASC, 字段2 DESC; # 按照字段1升序，相同时按字段2降序
</pre>

- 注意
- 列的别名可以在ORDER BY中使用

# 分页: LIMIT

- 基本操作

<pre>
SELECT 字段 FROM 表名 LIMIT 偏移,页长(条目数);
</pre>

- 注意
- *偏移以条目为单位，而非页长*
- *偏移为0时可以省略*
- *查询以偏移的下一条开始*
- MySQL8.0新特性

<pre>
SELECT 字段 FROM 表名 LIMIT 页长(条目数) OFFSET 偏移;
</pre>
